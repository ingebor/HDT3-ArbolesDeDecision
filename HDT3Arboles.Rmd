---
title: "HDT3Arboles"
author: "Ayleen Rubio 19003, Andrés Say 19705. Andreé Toledo 18439"
date: "8/3/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
#"C:/Users/andre/OneDrive/Documentos/HT1.Analisis-Exploratorio"
#Ingebor Rubio/Desktop/Trabajos/Quinto Semestre/Mineria/HDT1
#"C:/Users/andre/OneDrive/Documentos/HDT3-ArbolesDeDecision"

knitr::opts_knit$set(root.dir="C:/Users/andre/OneDrive/Documentos/HDT3-ArbolesDeDecision")

library(cluster) #Para calcular la silueta
library(e1071)#para cmeans
library(mclust) #mixtures of gaussians
library(fpc) #para hacer el plotcluster
library(NbClust) #Para determinar el n?mero de clusters ?ptimo
library(factoextra) #Para hacer gr?ficos bonitos de clustering
```

# Hoja de Trabajo No. 3: Árboles de Decisión  

## Análisis Exploratorio
A continuación se mostrará un resumen de cada una de las variables y el tipo 
```{r analisis, echo=FALSE}
datosCasas <- read.csv("train.csv")
summary(datosCasas)
str(datosCasas)
table(unlist(lapply(datosCasas, class)))
```
Con esto puede observarse que, del total de variables con las que cuenta nuestra base de datos, 43 son de tipo character y 38 son de tipo integer, siendo una de ellas el id por lo que no será utilizado en el futuro para formar grupos. 

De estas variables se ha considerado que algunas de ellas valen la pena estudiarlas más a fondo para conocer las condiciones de los datos con los que se llevará a cabo el entrenamiento y las pruebas.

```{r grfBldngCss, echo=FALSE}
barplot(datosCasas$LotArea, xlab= "Lote", ylab = "Metros cuadrados", main="Tamaño del lote en metros cuadrados")
```

En este caso, puede observarse que la mayoría de casas se encuentra debajo de los 50,ooo metros cuadrados y que la casa que cuenta con mayor área de lote cuenta con más de 200,000 metros cuadrados.

```{r echo=FALSE}
plot(x = datosCasas$SalePrice, y= datosCasas$LotArea, xlab= "Precio de la casa", ylab= "Tamaño del lote", main = "Correlación entre tamaño del lote y precio de la casa")
abline(lm(datosCasas$LotArea ~ datosCasas$SalePrice), col = "red")
```

Puede observarse que sí existe correlación entre el precio de la casa y el tamaño del lote, a pesar de que se cuente con algunos datos atípicos. En estos casos, puede que el precio de la casa varíe debido a el tipo de construcción o lo que se encuentre dentro de ella, como la cantidad de cuartos, baños, cocinas, entre otros.

```{r echo=FALSE}
library(ggplot2)
df <- as.data.frame(datosCasas$Condition1)
ggplot(data=df, aes(x=datosCasas$Condition1)) + geom_bar(stat="count", width=0.7, fill = "steelblue")+theme_minimal()
```

Puede observarse que la proximidad más común es la normal.

```{r echo=FALSE}
library(ggplot2)
df <- as.data.frame(datosCasas$HouseStyle)
ggplot(data=df, aes(x=datosCasas$HouseStyle)) + geom_bar(stat="count", width=0.7, fill = "steelblue")+theme_minimal()
```

Puede observarse cómo es que el tipo de vivienda más común es el de un solo nivel, seguido por las casas de 2 niveles.

```{r echo=FALSE}
library(ggplot2)
df <- as.data.frame(datosCasas$BldgType)
ggplot(data=df, aes(x=datosCasas$BldgType)) + geom_bar(stat="count", width=0.7, fill = "steelblue")+theme_minimal()
```

De la misma manera, puede observarse que los estilos de viviendas más comunes son para una sola familia.

```{r echo=FALSE}
library(ggplot2)
df <- as.data.frame(datosCasas$OverallQual)
ggplot(data=df, aes(x=datosCasas$OverallQual)) + geom_bar(stat="count", width=0.7, fill = "steelblue")+theme_minimal()
df2 <- as.data.frame(datosCasas$OverallCond)
ggplot(data=df2, aes(x=datosCasas$OverallCond)) + geom_bar(stat="count", width=0.7, fill = "steelblue")+theme_minimal()
```

En estos gráficos puede observarse que tanto los materiales, acabado y condidiones generales de las casas se encuentran en promedio en un valor de 5 de 10.

```{r echo=FALSE}
library(ggplot2)
df <- as.data.frame(datosCasas$YearBuilt)
ggplot(data=df, aes(x=datosCasas$YearBuilt)) + geom_bar(stat="count", width=0.7, fill = "steelblue")+theme_minimal()
df <- as.data.frame(datosCasas$YearRemodAdd)
ggplot(data=df, aes(x=datosCasas$YearRemodAdd)) + geom_bar(stat="count", width=0.7, fill = "steelblue")+theme_minimal()
```
Seccion de clustering 


```{r preprocesamiento, echo=FALSE}
datos <- datosCasas[,c(5,18,19,20,52,63,81)]
summary(datos)
```
Se trabajará con las siguientes variables que tienen formato int para formas grupos: LotArea, overallQual, overallCond, yearBuilt,bedroomAbvGr, GarageArea, SalePrice Esto debido a que son variables que se pueden clasificar por grupos y los resultados pueden ser interpretados.

Para saber la mejor cantidad de clusters a utilizar, se hará lo siguiente:
```{r cantClusters, echo=FALSE}
wss <- (nrow(datos[,1:7])-1)*sum(apply(datos[,1:7],2,var))

for (i in 2:10) 
  wss[i] <- sum(kmeans(datos[,1:7], centers=i)$withinss)

plot(1:10, wss, type="b", xlab="Number of Clusters",  ylab="Within groups sum of squares")

```


## Agrupamiento por medio de k-means  
```{r kmeans, echo=FALSE}
km<-kmeans(datos[,1:7],3,iter.max =100)
datos$grupo<-km$cluster

plotcluster(datos[,1:7],km$cluster)


```
Se puede observar cómo es que se han dividido los tres grupos, siendo el primero el de color negro, el segundo el de color rojo y el tercero el de color verde. 

## Agrupamiento por medio de clustering jerárquico
```{r jerarquico, echo=FALSE}
hc<-hclust(dist(datos[,1:7])) #Genera el clustering jerárquico de los datos
hc
plot(hc) #Genera el dendograma
rect.hclust(hc,k=3) #Dibuja el corte de los grupos en el gráfico
groups<-cutree(hc,k=3) #corta el dendograma, determinando el grupo de cada fila
datos$gruposHC<-groups


g1HC<-datos[datos$gruposHC==1,]
g2HC<-datos[datos$gruposHC==2,]
g3HC<-datos[datos$gruposHC==3,]

```

## Calidad del agrupamiento
### K-means
```{r calk, echo=FALSE}
silkm<-silhouette(km$cluster,dist(datos[,1:7]))
mean(silkm[,3])
```

### Cluster jerárquico
```{r caljer, echo=FALSE}
silch<-silhouette(groups,dist(datos[,1:7]))
mean(silch[,3])

```
Según los valores obtenidos, el que cuenta con la mayor silueta es el cluster jerárquico con un valor de 0.625, seguido de cerca de K means


```{r analisis de cada grupo K means, echo=FALSE}
summary(g1HC)
summary(g2HC)
summary(g3HC)

```
